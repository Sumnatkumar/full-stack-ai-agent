import { M as Message, T as Tool } from './agent-Prh3eG94.js';
export { A as Agent, E as AgentMessageChunk, F as AgentMessageChunkSchema, w as AgentResult, m as AnyZodType, $ as DataDeltaEvent, a5 as GenericErrorEvent, x as History, H as HistoryConfig, a0 as HitlRequestedEvent, a1 as HitlResolvedEvent, k as MCP, l as MaybePromise, a3 as MetadataUpdatedEvent, N as Network, d as NetworkRun, V as PartCompletedEvent, Q as PartCreatedEvent, W as PartFailedEvent, _ as ReasoningDeltaEvent, R as RoutingAgent, I as RunCompletedEvent, J as RunFailedEvent, K as RunInterruptedEvent, G as RunStartedEvent, z as SaveThreadToStorageConfig, f as State, S as StateData, O as StepCompletedEvent, P as StepFailedEvent, L as StepStartedEvent, a4 as StreamEndedEvent, a6 as StreamingConfig, a7 as StreamingContext, a8 as StreamingEvent, u as TextContent, X as TextDeltaEvent, q as TextMessage, y as ThreadOperationConfig, Y as ToolCallArgumentsDeltaEvent, r as ToolCallMessage, Z as ToolCallOutputDeltaEvent, v as ToolMessage, t as ToolResultMessage, h as ToolResultPayload, a2 as UsageUpdatedEvent, U as UserMessage, c as createAgent, b as createNetwork, a as createRoutingAgent, e as createState, ab as createStepWrapper, i as createTool, j as createToolManifest, aa as generateId, g as getDefaultRoutingAgent, p as getInngestFnInput, n as getStepTools, B as initializeThread, a9 as isEventType, o as isInngestFn, C as loadThreadFromStorage, D as saveThreadToStorage, s as stringifyError } from './agent-Prh3eG94.js';
import { AiAdapter } from '@inngest/ai';
export { anthropic, gemini, grok, openai } from '@inngest/ai';
import 'inngest';
import 'zod';
import 'inngest/experimental';
import '@modelcontextprotocol/sdk/client/streamableHttp.js';
import '@modelcontextprotocol/sdk/client/auth.js';

declare const createAgenticModelFromAiAdapter: <TAiAdapter extends AiAdapter.Any>(adapter: TAiAdapter) => AgenticModel<TAiAdapter>;
declare class AgenticModel<TAiAdapter extends AiAdapter.Any> {
    #private;
    requestParser: AgenticModel.RequestParser<TAiAdapter>;
    responseParser: AgenticModel.ResponseParser<TAiAdapter>;
    constructor({ model, requestParser, responseParser, }: AgenticModel.Constructor<TAiAdapter>);
    infer(stepID: string, input: Message[], tools: Tool.Any[], tool_choice: Tool.Choice): Promise<AgenticModel.InferenceResponse>;
}
declare namespace AgenticModel {
    type Any = AgenticModel<AiAdapter.Any>;
    /**
     * InferenceResponse is the response from a model for an inference request.
     * This contains parsed messages and the raw result, with the type of the raw
     * result depending on the model's API repsonse.
     */
    type InferenceResponse<T = unknown> = {
        output: Message[];
        raw: T;
    };
    interface Constructor<TAiAdapter extends AiAdapter.Any> {
        model: TAiAdapter;
        requestParser: RequestParser<TAiAdapter>;
        responseParser: ResponseParser<TAiAdapter>;
    }
    type RequestParser<TAiAdapter extends AiAdapter.Any> = (model: TAiAdapter, state: Message[], tools: Tool.Any[], tool_choice: Tool.Choice) => AiAdapter.Input<TAiAdapter>;
    type ResponseParser<TAiAdapter extends AiAdapter.Any> = (output: AiAdapter.Output<TAiAdapter>) => Message[];
}

export { AgenticModel, Message, Tool, createAgenticModelFromAiAdapter };
