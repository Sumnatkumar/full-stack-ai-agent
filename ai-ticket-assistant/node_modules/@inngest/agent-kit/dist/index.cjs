"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  Agent: () => Agent,
  AgentMessageChunkSchema: () => AgentMessageChunkSchema,
  AgentResult: () => AgentResult,
  AgenticModel: () => AgenticModel,
  Network: () => Network,
  NetworkRun: () => NetworkRun,
  RoutingAgent: () => RoutingAgent,
  State: () => State,
  StreamingContext: () => StreamingContext,
  anthropic: () => import_ai9.anthropic,
  createAgent: () => createAgent,
  createAgenticModelFromAiAdapter: () => createAgenticModelFromAiAdapter,
  createNetwork: () => createNetwork,
  createRoutingAgent: () => createRoutingAgent,
  createState: () => createState,
  createStepWrapper: () => createStepWrapper,
  createTool: () => createTool,
  createToolManifest: () => createToolManifest,
  gemini: () => import_ai9.gemini,
  generateId: () => generateId,
  getDefaultRoutingAgent: () => getDefaultRoutingAgent,
  getInngestFnInput: () => getInngestFnInput,
  getStepTools: () => getStepTools,
  grok: () => import_ai9.grok,
  initializeThread: () => initializeThread,
  isEventType: () => isEventType,
  isInngestFn: () => isInngestFn,
  loadThreadFromStorage: () => loadThreadFromStorage,
  openai: () => import_ai9.openai,
  saveThreadToStorage: () => saveThreadToStorage,
  stringifyError: () => stringifyError
});
module.exports = __toCommonJS(index_exports);

// src/agent.ts
var import_ai8 = require("@inngest/ai");
var import_client = require("@modelcontextprotocol/sdk/client/index.js");
var import_streamableHttp = require("@modelcontextprotocol/sdk/client/streamableHttp.js");
var import_sse = require("@modelcontextprotocol/sdk/client/sse.js");
var import_websocket = require("@modelcontextprotocol/sdk/client/websocket.js");
var import_stdio = require("@modelcontextprotocol/sdk/client/stdio.js");
var import_transport = require("@modelcontextprotocol/sdk/shared/transport.js");
var import_types6 = require("@modelcontextprotocol/sdk/types.js");
var import_eventsource = require("eventsource");
var import_crypto2 = require("crypto");
var import_inngest7 = require("inngest");
var import_internals = require("inngest/internals");
var import_inngest8 = require("inngest");
var import_types7 = require("inngest/types");

// src/model.ts
var import_ai7 = require("@inngest/ai");

// src/adapters/index.ts
var import_ai6 = require("@inngest/ai");

// src/adapters/anthropic.ts
var import_ai2 = require("@inngest/ai");
var import_zod5 = require("zod");

// src/types.ts
var import_xxhashjs = __toESM(require("xxhashjs"), 1);
var _checksum;
var AgentResult = class {
  constructor(agentName, output, toolCalls, createdAt, prompt, history, raw, id) {
    this.agentName = agentName;
    this.output = output;
    this.toolCalls = toolCalls;
    this.createdAt = createdAt;
    this.prompt = prompt;
    this.history = history;
    this.raw = raw;
    this.id = id;
    // checksum memoizes a checksum so that it doe snot have to be calculated many times.
    __privateAdd(this, _checksum);
  }
  /**
   * export returns all fields necessary to store the AgentResult for future use.
   */
  export() {
    return {
      agentName: this.agentName,
      output: this.output,
      toolCalls: this.toolCalls,
      createdAt: this.createdAt,
      checksum: this.checksum
    };
  }
  /**
   * checksum is a unique ID for this result.
   *
   * It is generated by taking a checksum of the message output and the created at date.
   * This allows you to dedupe items when saving conversation history.
   */
  get checksum() {
    if (__privateGet(this, _checksum) === void 0) {
      const input = JSON.stringify(this.output.concat(this.toolCalls)) + this.createdAt.toString();
      __privateSet(this, _checksum, import_xxhashjs.default.h64(input, 0).toString());
    }
    return __privateGet(this, _checksum);
  }
};
_checksum = new WeakMap();

// src/tool.ts
var import_inngest6 = require("inngest");
var import_zod4 = require("zod");

// src/state.ts
var createState = (initialState, opts) => {
  return new State(__spreadProps(__spreadValues({}, opts), { data: initialState }));
};
var __kv;
var _State = class _State {
  constructor({
    data,
    messages,
    threadId,
    results
  } = {}) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    __privateAdd(this, __kv);
    this._results = results || [];
    this._messages = messages || [];
    this._data = data ? __spreadValues({}, data) : {};
    this.threadId = threadId;
    this.data = new Proxy(this._data, {
      set: (target, prop, value) => {
        if (typeof prop === "string" && prop in target) {
          Reflect.set(target, prop, value);
          return true;
        }
        return Reflect.set(target, prop, value);
      }
    });
    __privateSet(this, __kv, new Map(Object.entries(this._data)));
    this.kv = {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      set: (key, value) => {
        __privateGet(this, __kv).set(key, value);
      },
      get: (key) => {
        return __privateGet(this, __kv).get(key);
      },
      delete: (key) => {
        return __privateGet(this, __kv).delete(key);
      },
      has: (key) => {
        return __privateGet(this, __kv).has(key);
      },
      all: () => {
        return Object.fromEntries(__privateGet(this, __kv));
      }
    };
  }
  /**
   * Results returns a new array containing all past inference results in the
   * network. This array is safe to modify.
   */
  get results() {
    return this._results.slice();
  }
  /**
   * Replaces all results with the provided array
   * used when loading initial results from history.get()
   */
  setResults(results) {
    this._results = results;
  }
  /**
   * Returns a slice of results from the given start index
   * used when saving results to a database via history.appendResults()
   */
  getResultsFrom(startIndex) {
    return this._results.slice(startIndex);
  }
  /**
   * Messages returns a new array containing all initial messages that were
   * provided to the constructor. This array is safe to modify.
   */
  get messages() {
    return this._messages.slice();
  }
  /**
   * formatHistory returns the memory used for agentic calls based off of prior
   * agentic calls.
   *
   * This is used to format the current State as a conversation log when
   * calling an individual agent.
   *
   */
  formatHistory(formatter) {
    if (!formatter) {
      formatter = defaultResultFormatter;
    }
    return this._messages.concat(
      this._results.map((result) => formatter(result)).flat()
    );
  }
  /**
   * appendResult appends a given result to the current state.  This
   * is called by the network after each iteration.
   */
  appendResult(call) {
    this._results.push(call);
  }
  /**
   * clone allows you to safely clone the state.
   */
  clone() {
    const state = new _State({
      data: this.data,
      threadId: this.threadId,
      messages: this._messages.slice(),
      results: this._results.slice()
    });
    return state;
  }
};
__kv = new WeakMap();
var State = _State;
var defaultResultFormatter = (r) => {
  return [].concat(r.output).concat(r.toolCalls);
};

// src/network.ts
var import_ai = require("@inngest/ai");
var import_crypto = require("crypto");
var import_zod3 = require("zod");

// src/util.ts
var import_inngest = require("inngest");
var import_inngest2 = require("inngest");
var import_experimental = require("inngest/experimental");
var import_zod = require("zod");
var stringifyError = (e) => {
  if (e instanceof Error) {
    return e.message;
  }
  return String(e);
};
var getStepTools = async () => {
  const asyncCtx = await (0, import_experimental.getAsyncCtx)();
  return asyncCtx == null ? void 0 : asyncCtx.ctx.step;
};
var isInngestFn = (fn) => {
  if ((0, import_inngest2.isInngestFunction)(fn)) {
    return true;
  }
  if (typeof fn === "object" && fn !== null && "createExecution" in fn && typeof fn.createExecution === "function") {
    return true;
  }
  return false;
};
var getInngestFnInput = (fn) => {
  var _a, _b, _c;
  const runtimeSchemas = (_a = fn["client"]["schemas"]) == null ? void 0 : _a["runtimeSchemas"];
  if (!runtimeSchemas) {
    return;
  }
  const schemasToAttempt = new Set(
    (_c = (_b = fn["opts"].triggers) == null ? void 0 : _b.reduce((acc, trigger) => {
      if (trigger.event) {
        return [...acc, trigger.event];
      }
      return acc;
    }, [])) != null ? _c : []
  );
  if (!schemasToAttempt.size) {
    return;
  }
  let schema;
  for (const eventSchema of schemasToAttempt) {
    const runtimeSchema = runtimeSchemas[eventSchema];
    if (typeof runtimeSchema === "object" && runtimeSchema !== null && "data" in runtimeSchema && helpers.isZodObject(runtimeSchema.data)) {
      if (schema) {
        schema = schema.or(runtimeSchema.data);
      } else {
        schema = runtimeSchema.data;
      }
      continue;
    }
  }
  return schema;
};
var helpers = {
  isZodObject: (value) => {
    return value instanceof import_zod.ZodObject;
  },
  isObject: (value) => {
    return typeof value === "object" && value !== null && !Array.isArray(value);
  }
};

// src/history.ts
var import_inngest3 = require("inngest");
async function initializeThread(config) {
  const { state, history, input, network } = config;
  if (!history) return;
  const step = await getStepTools();
  if (state.threadId && history.createThread) {
    await history.createThread({
      state,
      network,
      input,
      step
    });
    return;
  }
  if (!state.threadId && history.createThread) {
    const { threadId } = await history.createThread({
      state,
      network,
      input,
      step
    });
    state.threadId = threadId;
  } else if (!state.threadId && history.get) {
    state.threadId = crypto.randomUUID();
    if (history.createThread) {
      await history.createThread({
        state,
        network,
        input,
        step
      });
    }
  }
}
async function loadThreadFromStorage(config) {
  const { state, history, input, network } = config;
  if (!(history == null ? void 0 : history.get) || !state.threadId || state.results.length > 0 || state.messages.length > 0) {
    return;
  }
  const step = await getStepTools();
  const historyResults = await history.get({
    state,
    network,
    input,
    step,
    threadId: state.threadId
  });
  state.setResults(historyResults);
}
async function saveThreadToStorage(config) {
  const { state, history, initialResultCount, network, input } = config;
  if (!(history == null ? void 0 : history.appendResults)) return;
  const step = await getStepTools();
  const newResults = state.getResultsFrom(initialResultCount);
  await history.appendResults({
    state,
    network,
    step,
    newResults,
    input,
    threadId: state.threadId
  });
}

// src/streaming.ts
var import_inngest4 = require("inngest");
var import_inngest5 = require("inngest");
var import_zod2 = require("zod");
var AgentMessageChunkSchema = import_zod2.z.object({
  event: import_zod2.z.string(),
  data: import_zod2.z.record(import_zod2.z.string(), import_zod2.z.any()),
  timestamp: import_zod2.z.number(),
  sequenceNumber: import_zod2.z.number(),
  id: import_zod2.z.string()
});
var SequenceCounter = class {
  constructor() {
    this.value = 0;
  }
  getNext() {
    return this.value++;
  }
  current() {
    return this.value;
  }
};
var StreamingContext = class _StreamingContext {
  constructor(config) {
    var _a, _b;
    this.publish = config.publish;
    this.runId = config.runId;
    this.parentRunId = config.parentRunId;
    this.messageId = config.messageId;
    this.threadId = config.threadId;
    this.userId = config.userId;
    this.scope = config.scope;
    this.sequenceCounter = config.sequenceCounter || new SequenceCounter();
    this.debug = (_a = config.debug) != null ? _a : process.env.NODE_ENV === "development";
    this.simulateChunking = (_b = config.simulateChunking) != null ? _b : false;
  }
  /**
   * Create a child streaming context for agent runs within network runs
   */
  createChildContext(agentRunId) {
    return new _StreamingContext({
      publish: this.publish,
      runId: agentRunId,
      parentRunId: this.runId,
      messageId: this.messageId,
      threadId: this.threadId,
      userId: this.userId,
      scope: "agent",
      sequenceCounter: this.sequenceCounter,
      // Share the same counter
      debug: this.debug,
      // Inherit debug setting
      simulateChunking: this.simulateChunking
    });
  }
  /**
   * Create a context with different messageId but shared sequence counter
   */
  createContextWithSharedSequence(config) {
    return new _StreamingContext({
      publish: this.publish,
      runId: config.runId,
      parentRunId: this.runId,
      messageId: config.messageId,
      threadId: this.threadId,
      userId: this.userId,
      scope: config.scope,
      sequenceCounter: this.sequenceCounter,
      // Share the same counter instance
      debug: this.debug,
      // Inherit debug setting
      simulateChunking: this.simulateChunking
    });
  }
  /**
   * Extract context information from network state
   */
  static fromNetworkState(networkState, config) {
    var _a, _b;
    const debug = (_a = config.debug) != null ? _a : process.env.NODE_ENV === "development";
    return new _StreamingContext({
      publish: config.publish,
      runId: config.runId,
      messageId: config.messageId,
      threadId: networkState.threadId,
      userId: typeof networkState.data.userId === "string" ? networkState.data.userId : void 0,
      scope: config.scope,
      debug,
      simulateChunking: (_b = config.simulateChunking) != null ? _b : false
    });
  }
  /**
   * Publish an event with automatic sequence numbering.
   * Provides a stepId in the chunk for optional Inngest step wrapping by the developer.
   */
  async publishEvent(event) {
    const sequenceNumber = this.sequenceCounter.getNext();
    const stepId = this.generateStreamingStepId(event, sequenceNumber);
    const enrichedData = __spreadValues({}, event.data);
    if (this.threadId) {
      enrichedData["threadId"] = this.threadId;
    }
    if (this.userId) {
      enrichedData["userId"] = this.userId;
    }
    const chunk = __spreadProps(__spreadValues({}, event), {
      data: enrichedData,
      timestamp: Date.now(),
      sequenceNumber,
      id: stepId
    });
    try {
      await this.publish(chunk);
    } catch (err) {
      console.warn(
        "[Streaming] Failed to publish event; continuing execution",
        {
          error: err instanceof Error ? err.message : String(err),
          event: chunk.event,
          sequenceNumber: chunk.sequenceNumber
        }
      );
    }
  }
  /**
   * Generate intelligent step IDs for streaming events
   */
  generateStreamingStepId(event, sequenceNumber) {
    return `publish-${sequenceNumber}:${event.event}`;
  }
  /**
   * Generate a unique part ID for this streaming context
   * OpenAI requires tool call IDs to be ≤ 40 characters
   */
  generatePartId() {
    const shortMessageId = this.messageId.replace(/-/g, "").substring(0, 8);
    const shortTimestamp = Date.now().toString().slice(-8);
    const randomSuffix = Math.random().toString(36).substr(2, 6);
    const partId = `tool_${shortMessageId}_${shortTimestamp}_${randomSuffix}`;
    return partId;
  }
  /**
   * Generate a unique step ID for this streaming context
   */
  generateStepId(baseName) {
    return `step_${baseName}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  /** Returns whether simulated chunking is enabled for this context */
  isSimulatedChunking() {
    return this.simulateChunking;
  }
};
function isEventType(event, eventType) {
  return event.event === eventType;
}
function generateId() {
  const id = `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  return id;
}
function createStepWrapper(originalStep, context) {
  if (!context || !originalStep) {
    return originalStep;
  }
  return new Proxy(originalStep, {
    get(target, prop, receiver) {
      if (prop === "run") {
        return async (stepId, fn) => {
          const originalRun = Reflect.get(
            target,
            "run",
            receiver
          );
          return originalRun(stepId, fn);
        };
      }
      return Reflect.get(
        target,
        prop,
        receiver
      );
    }
  });
}

// src/network.ts
var createNetwork = (opts) => new Network(opts);
var Network = class {
  constructor({
    name,
    description,
    agents,
    defaultModel,
    maxIter,
    defaultState,
    router,
    defaultRouter,
    history
  }) {
    this._counter = 0;
    this.name = name;
    this.description = description;
    this.agents = /* @__PURE__ */ new Map();
    this._agents = /* @__PURE__ */ new Map();
    this.defaultModel = defaultModel;
    this.router = defaultRouter != null ? defaultRouter : router;
    this.maxIter = maxIter || 0;
    this._stack = [];
    this.history = history;
    if (defaultState) {
      this.state = defaultState;
    } else {
      this.state = createState();
    }
    for (const agent of agents) {
      this.agents.set(agent.name, agent);
      this._agents.set(agent.name, agent);
    }
  }
  async availableAgents(networkRun = new NetworkRun(this, new State())) {
    var _a;
    const available = [];
    const all = Array.from(this.agents.values());
    for (const a of all) {
      const enabled = (_a = a == null ? void 0 : a.lifecycles) == null ? void 0 : _a.enabled;
      if (!enabled || await enabled({ agent: a, network: networkRun })) {
        available.push(a);
      }
    }
    return available;
  }
  /**
   * addAgent adds a new agent to the network.
   */
  addAgent(agent) {
    this.agents.set(agent.name, agent);
  }
  /**
   * run handles a given request using the network of agents.  It is not
   * concurrency-safe; you can only call run on a network once, as networks are
   * stateful.
   *
   */
  run(...[input, overrides]) {
    var _a;
    if (typeof input === "object" && typeof input.clientTimestamp === "string") {
      input.clientTimestamp = new Date(input.clientTimestamp);
    }
    let state;
    if (overrides == null ? void 0 : overrides.state) {
      if (overrides.state instanceof State) {
        state = overrides.state;
      } else {
        const stateObj = overrides.state;
        state = new State({
          data: stateObj.data || {},
          messages: stateObj._messages || [],
          results: stateObj._results || []
        });
      }
    } else {
      state = ((_a = this.state) == null ? void 0 : _a.clone()) || new State();
    }
    return new NetworkRun(this, state)["execute"](input, overrides);
  }
};
var defaultRoutingAgent;
var getDefaultRoutingAgent = () => {
  defaultRoutingAgent != null ? defaultRoutingAgent : defaultRoutingAgent = createRoutingAgent({
    name: "Default routing agent",
    description: "Selects which agents to work on based off of the current prompt and input.",
    lifecycle: {
      onRoute: ({ result }) => {
        const tool = result.toolCalls[0];
        if (!tool) {
          return;
        }
        if (tool.tool.name === "done") {
          return void 0;
        }
        if (tool.tool.name === "select_agent") {
          if (typeof tool.content === "object" && tool.content !== null && "data" in tool.content && typeof tool.content.data === "string") {
            return [tool.content.data];
          }
        }
        return;
      }
    },
    tools: [
      createTool({
        name: "select_agent",
        description: "Select an agent to handle the next step of the conversation",
        parameters: import_zod3.z.object({
          name: import_zod3.z.string().describe("The name of the agent that should handle the request"),
          reason: import_zod3.z.string().optional().describe("Brief explanation of why this agent was chosen")
        }).strict(),
        handler: ({ name }, { network }) => {
          if (typeof name !== "string") {
            throw new Error("The routing agent requested an invalid agent");
          }
          const agent = network.agents.get(name);
          if (agent === void 0) {
            throw new Error(
              `The routing agent requested an agent that doesn't exist: ${name}`
            );
          }
          return agent.name;
        }
      }),
      createTool({
        name: "done",
        description: "Signal that the conversation is complete and no more agents need to be called",
        parameters: import_zod3.z.object({
          summary: import_zod3.z.string().optional().describe("Brief summary of what was accomplished")
        }).strict(),
        handler: ({ summary }) => {
          return summary || "Conversation completed successfully";
        }
      })
    ],
    tool_choice: "any",
    // Allow the model to choose between select_agent or done
    system: async ({ network }) => {
      if (!network) {
        throw new Error(
          "The routing agent can only be used within a network of agents"
        );
      }
      const agents = await (network == null ? void 0 : network.availableAgents());
      return `You are the orchestrator between a group of agents. Each agent is suited for specific tasks and has a name, description, and tools.

The following agents are available:
<agents>
  ${agents.map((a) => {
        return `
    <agent>
      <name>${a.name}</name>
      <description>${a.description}</description>
      <tools>${JSON.stringify(Array.from(a.tools.values()))}</tools>
    </agent>`;
      }).join("\n")}
</agents>

Your responsibilities:
1. Analyze the conversation history and current state
2. Determine if the request has been completed or if more work is needed
3. Either:
   - Call select_agent to route to the appropriate agent for the next step
   - Call done if the conversation is complete or the user's request has been fulfilled

<instructions>
  - If the user's request has been addressed and no further action is needed, call the done tool
  - If more work is needed, select the most appropriate agent based on their capabilities
  - Consider the context and history when making routing decisions
  - Be efficient - don't route to agents unnecessarily if the task is complete
</instructions>`;
    }
  });
  return defaultRoutingAgent;
};
var NetworkRun = class extends Network {
  constructor(network, state) {
    super({
      name: network.name,
      description: network.description,
      agents: Array.from(network.agents.values()),
      defaultModel: network.defaultModel,
      defaultState: network.state,
      router: network.router,
      maxIter: network.maxIter,
      history: network.history
    });
    this.state = state;
  }
  run() {
    throw new Error("NetworkRun does not support run");
  }
  async availableAgents() {
    return super.availableAgents(this);
  }
  /**
   * Schedule is used to push an agent's run function onto the stack.
   */
  schedule(agentName) {
    this["_stack"].push(agentName);
  }
  async execute(...[input, overrides]) {
    var _a, _b, _c;
    const stepTools = await getStepTools();
    let networkRunId;
    if (stepTools) {
      networkRunId = await stepTools.run("generate-network-id", () => {
        return (0, import_crypto.randomUUID)();
      });
    } else {
      networkRunId = (0, import_crypto.randomUUID)();
    }
    const streamingPublish = (_a = overrides == null ? void 0 : overrides.streaming) == null ? void 0 : _a.publish;
    let streamingContext;
    const inputContent = typeof input === "object" && input !== null && "content" in input ? input.content : input;
    const hadClientThreadId = Boolean(this.state.threadId);
    await initializeThread({
      state: this.state,
      history: this.history,
      input: inputContent,
      network: this
    });
    if ((_b = this.history) == null ? void 0 : _b.appendUserMessage) {
      let userMessage;
      if (typeof input === "object" && input !== null && "id" in input) {
        const userInput = input;
        const timestamp = userInput.clientTimestamp instanceof Date ? userInput.clientTimestamp : userInput.clientTimestamp ? new Date(userInput.clientTimestamp) : /* @__PURE__ */ new Date();
        userMessage = {
          id: userInput.id,
          content: userInput.content,
          role: "user",
          timestamp
        };
      } else {
        userMessage = {
          id: (0, import_crypto.randomUUID)(),
          content: input,
          role: "user",
          timestamp: /* @__PURE__ */ new Date()
        };
      }
      await this.history.appendUserMessage({
        state: this.state,
        network: this,
        input: inputContent,
        threadId: this.state.threadId,
        userMessage,
        step: stepTools || void 0
      });
    }
    if (hadClientThreadId) {
      await loadThreadFromStorage({
        state: this.state,
        history: this.history,
        input: inputContent,
        network: this
      });
    }
    if (streamingPublish) {
      streamingContext = StreamingContext.fromNetworkState(this.state, {
        publish: streamingPublish,
        runId: networkRunId,
        messageId: networkRunId,
        // Use networkRunId as messageId for network-level events
        scope: "network",
        simulateChunking: (_c = overrides == null ? void 0 : overrides.streaming) == null ? void 0 : _c.simulateChunking
      });
      await streamingContext.publishEvent({
        event: "run.started",
        data: {
          runId: networkRunId,
          scope: "network",
          name: this.name,
          messageId: networkRunId,
          // Network events use networkRunId as messageId
          threadId: this.state.threadId
        }
      });
    }
    const step = await getStepTools();
    const wrappedStep = createStepWrapper(step, streamingContext);
    const available = await this.availableAgents();
    if (available.length === 0) {
      throw new Error("no agents enabled in network");
    }
    const initialResultCount = this.state.results.length;
    try {
      const next = await this.getNextAgents(
        input,
        // Pass full UserMessage object, not extracted content
        (overrides == null ? void 0 : overrides.router) || (overrides == null ? void 0 : overrides.defaultRouter) || this.router
      );
      if (!(next == null ? void 0 : next.length)) {
        return this;
      }
      for (const agent of next) {
        this.schedule(agent.name);
      }
      while (this._stack.length > 0 && (this.maxIter === 0 || this._counter < this.maxIter)) {
        const agentName = this._stack.shift();
        const agent = agentName && this._agents.get(agentName);
        if (!agent) {
          if (streamingContext) {
            await streamingContext.publishEvent({
              event: "run.completed",
              data: {
                runId: networkRunId,
                scope: "network",
                name: this.name,
                messageId: networkRunId
                // Use networkRunId for network completion
              }
            });
            await streamingContext.publishEvent({
              event: "stream.ended",
              data: {
                scope: "network",
                messageId: networkRunId
              }
            });
          }
          return this;
        }
        let agentRunId;
        let agentMessageId;
        if (stepTools) {
          const agentIds = await stepTools.run(
            `generate-agent-ids-${this._counter}`,
            () => {
              return {
                agentRunId: generateId(),
                agentMessageId: (0, import_crypto.randomUUID)()
              };
            }
          );
          agentRunId = agentIds.agentRunId;
          agentMessageId = agentIds.agentMessageId;
        } else {
          agentRunId = generateId();
          agentMessageId = (0, import_crypto.randomUUID)();
        }
        let agentStreamingContext;
        if (streamingContext) {
          agentStreamingContext = streamingContext.createContextWithSharedSequence({
            runId: agentRunId,
            messageId: agentMessageId,
            scope: "agent"
          });
          await streamingContext.publishEvent({
            event: "run.started",
            data: {
              runId: agentRunId,
              parentRunId: networkRunId,
              scope: "agent",
              name: agent.name,
              messageId: agentMessageId
              // Use agent-specific messageId
            }
          });
        }
        const call = await agent.run(inputContent, {
          network: this,
          maxIter: 0,
          // Provide streaming context so the agent can emit part/text/tool events
          streamingContext: agentStreamingContext,
          // Provide wrapped step tools for automatic step lifecycle events
          step: wrappedStep
        });
        call.id = agentMessageId;
        if (agentStreamingContext) {
          await agentStreamingContext.publishEvent({
            event: "run.completed",
            data: {
              runId: agentRunId,
              scope: "agent",
              name: agent.name,
              messageId: agentMessageId
              // Include agent-specific messageId in completion event
            }
          });
        }
        this._counter += 1;
        this.state.appendResult(call);
        const next2 = await this.getNextAgents(
          input,
          // Pass full UserMessage object, not extracted content
          (overrides == null ? void 0 : overrides.router) || (overrides == null ? void 0 : overrides.defaultRouter) || this.router
        );
        for (const a of next2 || []) {
          this.schedule(a.name);
        }
      }
      await saveThreadToStorage({
        state: this.state,
        history: this.history,
        input: inputContent,
        initialResultCount,
        network: this
      });
    } catch (error) {
      if (streamingContext) {
        try {
          await streamingContext.publishEvent({
            event: "run.failed",
            data: {
              runId: networkRunId,
              scope: "network",
              name: this.name,
              messageId: networkRunId,
              // Use networkRunId for network error events
              error: error instanceof Error ? error.message : String(error),
              recoverable: false
            }
          });
        } catch (streamingError) {
          console.warn("Failed to publish run.failed event:", streamingError);
        }
      }
      throw error;
    } finally {
      if (streamingContext) {
        try {
          await streamingContext.publishEvent({
            event: "run.completed",
            data: {
              runId: networkRunId,
              scope: "network",
              name: this.name,
              messageId: networkRunId
              // Use networkRunId for network completion in finally block
            }
          });
          await streamingContext.publishEvent({
            event: "stream.ended",
            data: {
              scope: "network",
              messageId: networkRunId
            }
          });
        } catch (streamingError) {
          console.warn("Failed to publish completion events:", streamingError);
        }
      }
    }
    return this;
  }
  async getNextAgents(input, router) {
    if (!router && !this.defaultModel) {
      throw new Error(
        "No router or model defined in network.  You must pass a router or a default model to use the built-in agentic router."
      );
    }
    if (!router) {
      router = getDefaultRoutingAgent();
    }
    if (router instanceof RoutingAgent) {
      const inputContent = typeof input === "object" && input !== null && "content" in input ? input.content : input;
      return await this.getNextAgentsViaRoutingAgent(router, inputContent);
    }
    const stack = this._stack.map((name) => {
      const agent2 = this._agents.get(name);
      if (!agent2) {
        throw new Error(`unknown agent in the network stack: ${name}`);
      }
      return agent2;
    });
    const routerInputContent = typeof input === "object" && input !== null && "content" in input ? input.content : input;
    const agent = await router({
      input: routerInputContent,
      // Always pass string content for backwards compatibility
      userMessage: typeof input === "object" && input !== null && "content" in input ? input : void 0,
      network: this,
      stack,
      lastResult: this.state.results[this.state.results.length - 1],
      callCount: this._counter
    });
    if (!agent) {
      return;
    }
    if (agent instanceof RoutingAgent) {
      const inputContent = typeof input === "object" && input !== null && "content" in input ? input.content : input;
      return await this.getNextAgentsViaRoutingAgent(agent, inputContent);
    }
    for (const a of Array.isArray(agent) ? agent : [agent]) {
      if (!this._agents.has(a.name)) {
        this._agents.set(a.name, a);
      }
    }
    return Array.isArray(agent) ? agent : [agent];
  }
  async getNextAgentsViaRoutingAgent(routingAgent, input) {
    const result = await routingAgent.run(input, {
      network: this,
      model: routingAgent.model || this.defaultModel
    });
    const agentNames = routingAgent.lifecycles.onRoute({
      result,
      agent: routingAgent,
      network: this
    });
    return (agentNames || []).map((name) => this.agents.get(name)).filter(Boolean);
  }
};

// src/tool.ts
function createTool({
  name,
  description,
  parameters,
  handler
}) {
  return {
    name,
    description,
    parameters,
    handler(input, opts) {
      return handler(input, opts);
    }
  };
}
function createToolManifest(tools) {
  const manifest = {};
  for (const t of tools) {
    manifest[t.name] = { input: {}, output: {} };
  }
  return manifest;
}

// src/adapters/anthropic.ts
var requestParser = (model, messages, tools, tool_choice = "auto") => {
  const systemMessage = messages.find(
    (m) => m.role === "system" && m.type === "text"
  );
  const system = typeof (systemMessage == null ? void 0 : systemMessage.content) === "string" ? systemMessage.content : "";
  const anthropicMessages = messages.filter((m) => m.role !== "system").reduce(
    (acc, m) => {
      switch (m.type) {
        case "text":
          return [
            ...acc,
            {
              role: m.role,
              content: Array.isArray(m.content) ? m.content.map((text) => ({ type: "text", text })) : m.content
            }
          ];
        case "tool_call":
          return [
            ...acc,
            {
              role: m.role,
              content: m.tools.map((tool) => ({
                type: "tool_use",
                id: tool.id,
                input: tool.input,
                name: tool.name
              }))
            }
          ];
        case "tool_result":
          return [
            ...acc,
            {
              role: "user",
              content: [
                {
                  type: "tool_result",
                  tool_use_id: m.tool.id,
                  content: typeof m.content === "string" ? m.content : JSON.stringify(m.content)
                }
              ]
            }
          ];
      }
    },
    []
  );
  const lastMessage = anthropicMessages[anthropicMessages.length - 1];
  if ((lastMessage == null ? void 0 : lastMessage.role) === "assistant") {
    lastMessage.role = "user";
  }
  const request = {
    system,
    model: model.options.model,
    max_tokens: model.options.defaultParameters.max_tokens,
    messages: anthropicMessages
  };
  if (tools == null ? void 0 : tools.length) {
    request.tools = tools.map((t) => {
      return {
        name: t.name,
        description: t.description,
        input_schema: t.parameters ? import_zod5.z.toJSONSchema(t.parameters, {
          target: "draft-2020-12"
        }) : import_zod5.z.toJSONSchema(import_zod5.z.object({}), {
          target: "draft-2020-12"
        })
      };
    });
    request.tool_choice = toolChoice(tool_choice);
  }
  return request;
};
var responseParser = (input) => {
  var _a, _b;
  if (input.type === "error") {
    throw new Error(
      ((_a = input.error) == null ? void 0 : _a.message) || `Anthropic request failed: ${JSON.stringify(input.error)}`
    );
  }
  return ((_b = input == null ? void 0 : input.content) != null ? _b : []).reduce((acc, item) => {
    if (!item.type) {
      return acc;
    }
    switch (item.type) {
      case "text":
        return [
          ...acc,
          {
            type: "text",
            role: input.role,
            content: item.text,
            // XXX: Better stop reason parsing
            stop_reason: "stop"
          }
        ];
      case "tool_use": {
        let args;
        try {
          args = typeof item.input === "string" ? JSON.parse(item.input) : item.input;
        } catch (e) {
          args = item.input;
        }
        return [
          ...acc,
          {
            type: "tool_call",
            role: input.role,
            stop_reason: "tool",
            tools: [
              {
                type: "tool",
                id: item.id,
                name: item.name,
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                input: args
              }
            ]
          }
        ];
      }
    }
  }, []);
};
var toolChoice = (choice) => {
  switch (choice) {
    case "auto":
      return { type: "auto" };
    case "any":
      return { type: "any" };
    default:
      if (typeof choice === "string") {
        return {
          type: "tool",
          name: choice
        };
      }
  }
};

// src/adapters/openai.ts
var import_ai3 = require("@inngest/ai");
var import_zod6 = require("zod");
var requestParser2 = (model, messages, tools, tool_choice = "auto") => {
  var _a, _b;
  const request = {
    messages: messages.map((m) => {
      var _a2;
      switch (m.type) {
        case "text":
          return {
            role: m.role,
            content: m.content
          };
        case "tool_call":
          return {
            role: "assistant",
            content: null,
            tool_calls: m.tools ? (_a2 = m.tools) == null ? void 0 : _a2.map((tool) => ({
              id: tool.id,
              type: "function",
              function: {
                name: tool.name,
                arguments: JSON.stringify(tool.input)
              }
            })) : void 0
          };
        case "tool_result":
          return {
            role: "tool",
            tool_call_id: m.tool.id,
            content: typeof m.content === "string" ? m.content : JSON.stringify(m.content)
          };
      }
    })
  };
  if (tools == null ? void 0 : tools.length) {
    request.tool_choice = toolChoice2(tool_choice);
    if (!((_a = model.options.model) == null ? void 0 : _a.includes("o3")) && !((_b = model.options.model) == null ? void 0 : _b.includes("o1"))) {
      request.parallel_tool_calls = false;
    }
    request.tools = tools.map((t) => {
      return {
        type: "function",
        function: {
          name: t.name,
          description: t.description,
          parameters: t.parameters && import_zod6.z.toJSONSchema(t.parameters, { target: "draft-7" }),
          strict: typeof t.strict !== "undefined" ? t.strict : Boolean(t.parameters)
          // strict mode is only supported with parameters
        }
      };
    });
  }
  return request;
};
var responseParser2 = (input) => {
  var _a;
  if (input.error) {
    throw new Error(
      input.error.message || `OpenAI request failed: ${JSON.stringify(input.error)}`
    );
  }
  return ((_a = input == null ? void 0 : input.choices) != null ? _a : []).reduce((acc, choice) => {
    var _a2, _b;
    const { message, finish_reason } = choice;
    if (!message) {
      return acc;
    }
    const base = {
      role: choice.message.role,
      stop_reason: openAiStopReasonToStateStopReason[finish_reason != null ? finish_reason : ""] || "stop"
    };
    if (message.content && message.content.trim() !== "") {
      acc.push(__spreadProps(__spreadValues({}, base), {
        type: "text",
        content: message.content
      }));
    }
    if (((_b = (_a2 = message.tool_calls) == null ? void 0 : _a2.length) != null ? _b : 0) > 0) {
      acc.push(__spreadProps(__spreadValues({}, base), {
        type: "tool_call",
        tools: message.tool_calls.map((tool) => {
          return {
            type: "tool",
            id: tool.id,
            name: tool.function.name,
            function: tool.function.name,
            // Duplicate for backward compatibility
            // Use safe parser to handle OpenAI's JSON quirks (like backticks in strings)
            input: safeParseOpenAIJson(tool.function.arguments || "{}")
          };
        })
      }));
    }
    return acc;
  }, []);
};
var safeParseOpenAIJson = (str) => {
  const trimmed = str.replace(/^["']|["']$/g, "");
  try {
    return JSON.parse(trimmed);
  } catch (e) {
    try {
      const withQuotes = trimmed.replace(
        /`([\s\S]*?)`/g,
        (_, content) => JSON.stringify(content)
      );
      return JSON.parse(withQuotes);
    } catch (e2) {
      throw new Error(
        `Failed to parse JSON with backticks: ${stringifyError(e2)}`
      );
    }
  }
};
var openAiStopReasonToStateStopReason = {
  tool_calls: "tool",
  stop: "stop",
  length: "stop",
  content_filter: "stop",
  function_call: "tool"
};
var toolChoice2 = (choice) => {
  switch (choice) {
    case "auto":
      return "auto";
    case "any":
      return "required";
    default:
      return {
        type: "function",
        function: { name: choice }
      };
  }
};

// src/adapters/azure-openai.ts
var import_ai4 = require("@inngest/ai");
var requestParser3 = (model, messages, tools, tool_choice = "auto") => requestParser2(
  model,
  messages,
  tools,
  tool_choice
);
var responseParser3 = (output) => responseParser2(output);

// src/adapters/gemini.ts
var import_ai5 = require("@inngest/ai");
var import_zod7 = require("zod");
var requestParser4 = (_model2, messages, tools, tool_choice = "auto") => {
  const contents = messages.map((m) => messageToContent(m));
  const functionDeclarations = tools.map((t) => ({
    name: t.name,
    description: t.description,
    parameters: t.parameters ? geminiZodToJsonSchema(t.parameters) : (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      geminiZodToJsonSchema(import_zod7.z.object({}))
    )
  }));
  return __spreadValues({
    contents
  }, tools.length > 0 ? {
    tools: [
      {
        functionDeclarations
      }
    ],
    tool_config: toolChoice3(tool_choice)
  } : {});
};
var messageContentToString = (content) => {
  if (typeof content === "string") {
    return content;
  }
  return content.map((c) => c.text).join("");
};
var responseParser4 = (input) => {
  var _a, _b, _c;
  if (input.error) {
    throw new Error(
      ((_a = input.error) == null ? void 0 : _a.message) || `Gemini request failed: ${JSON.stringify(input.error)}`
    );
  }
  const messages = [];
  for (const candidate of (_b = input.candidates) != null ? _b : []) {
    if (candidate.finishReason === "MALFORMED_FUNCTION_CALL") {
      console.warn(
        "Gemini returned MALFORMED_FUNCTION_CALL, skipping this candidate. This typically indicates an issue with tool/function call formatting. Check your tool definitions and parameters."
      );
      continue;
    }
    if (!((_c = candidate.content) == null ? void 0 : _c.parts)) {
      continue;
    }
    for (const content of candidate.content.parts) {
      if (candidate.content.role === "user" && "text" in content) {
        messages.push({
          role: "user",
          type: "text",
          content: content.text
        });
      } else if (candidate.content.role === "model" && "text" in content) {
        messages.push({
          role: "assistant",
          type: "text",
          content: content.text
        });
      } else if (candidate.content.role === "model" && "functionCall" in content) {
        messages.push({
          role: "assistant",
          type: "tool_call",
          stop_reason: "tool",
          tools: [
            {
              name: content.functionCall.name,
              input: content.functionCall.args,
              type: "tool",
              id: content.functionCall.name
            }
          ]
        });
      } else if (candidate.content.role === "user" && "functionResponse" in content) {
        messages.push({
          role: "tool_result",
          type: "tool_result",
          stop_reason: "tool",
          tool: {
            name: content.functionResponse.name,
            input: content.functionResponse.response,
            type: "tool",
            id: content.functionResponse.name
          },
          content: JSON.stringify(content.functionResponse.response)
        });
      } else {
        throw new Error("Unknown content type");
      }
    }
  }
  return messages;
};
var messageToContent = (m) => {
  switch (m.role) {
    case "system":
      return {
        role: "user",
        parts: [{ text: messageContentToString(m.content) }]
      };
    case "user":
      switch (m.type) {
        case "tool_call":
          if (m.tools.length === 0) {
            throw new Error("Tool call message must have at least one tool");
          }
          return {
            role: "model",
            parts: [
              {
                functionCall: {
                  name: m.tools[0].name,
                  args: m.tools[0].input
                }
              }
            ]
          };
        case "text":
        default:
          return {
            role: "user",
            parts: [{ text: messageContentToString(m.content) }]
          };
      }
    case "assistant":
      switch (m.type) {
        case "tool_call":
          if (m.tools.length === 0) {
            throw new Error("Tool call message must have at least one tool");
          }
          return {
            role: "model",
            parts: [
              {
                functionCall: {
                  name: m.tools[0].name,
                  args: m.tools[0].input
                }
              }
            ]
          };
        case "text":
        default:
          return {
            role: "model",
            parts: [{ text: messageContentToString(m.content) }]
          };
      }
    case "tool_result":
      return {
        role: "user",
        parts: [
          {
            functionResponse: {
              name: m.tool.name,
              response: {
                name: m.tool.name,
                content: typeof m.content === "string" ? m.content : JSON.stringify(m.content)
              }
            }
          }
        ]
      };
    default:
      throw new Error(`Unknown message role: ${m.role}`);
  }
};
var toolChoice3 = (choice) => {
  switch (choice) {
    case "auto":
      return {
        functionCallingConfig: {
          mode: "AUTO"
        }
      };
    case "any":
      return {
        functionCallingConfig: {
          mode: "ANY"
        }
      };
    default:
      if (typeof choice === "string") {
        return {
          functionCallingConfig: {
            mode: "ANY",
            allowedFunctionNames: [choice]
          }
        };
      }
  }
};
var recursiveGeminiZodToJsonSchema = (obj) => {
  if (obj === null || obj === void 0 || typeof obj !== "object") {
    return obj;
  }
  if (Array.isArray(obj)) {
    return obj.map(recursiveGeminiZodToJsonSchema);
  }
  const newObj = __spreadValues({}, obj);
  for (const key in newObj) {
    if (newObj[key] != null) {
      newObj[key] = recursiveGeminiZodToJsonSchema(
        newObj[key]
      );
    }
  }
  if ((newObj == null ? void 0 : newObj["additionalProperties"]) != null) {
    delete newObj["additionalProperties"];
  }
  return newObj;
};
var geminiZodToJsonSchema = (schemaIn) => {
  let schema = import_zod7.z.toJSONSchema(schemaIn, { target: "openapi-3.0", io: "input" });
  schema = recursiveGeminiZodToJsonSchema(schema);
  return schema;
};

// src/adapters/grok.ts
var requestParser5 = (model, messages, tools, tool_choice = "auto") => {
  const request = requestParser2(
    model,
    messages,
    tools,
    tool_choice
  );
  request.tools = (request.tools || []).map((tool) => __spreadProps(__spreadValues({}, tool), {
    function: __spreadProps(__spreadValues({}, tool.function), {
      strict: false
    })
  }));
  return request;
};
var responseParser5 = responseParser2;

// src/adapters/index.ts
var adapters = {
  "openai-chat": {
    request: requestParser2,
    response: responseParser2
  },
  "azure-openai": {
    request: requestParser3,
    response: responseParser3
  },
  anthropic: {
    request: requestParser,
    response: responseParser
  },
  gemini: {
    request: requestParser4,
    response: responseParser4
  },
  grok: {
    request: requestParser5,
    response: responseParser5
  }
};

// src/model.ts
var createAgenticModelFromAiAdapter = (adapter) => {
  const opts = adapters[adapter.format];
  return new AgenticModel({
    model: adapter,
    requestParser: opts.request,
    responseParser: opts.response
  });
};
var _model;
var AgenticModel = class {
  constructor({
    model,
    requestParser: requestParser6,
    responseParser: responseParser6
  }) {
    __privateAdd(this, _model);
    __privateSet(this, _model, model);
    this.requestParser = requestParser6;
    this.responseParser = responseParser6;
  }
  async infer(stepID, input, tools, tool_choice) {
    var _a, _b;
    const body = this.requestParser(__privateGet(this, _model), input, tools, tool_choice);
    let result;
    const step = await getStepTools();
    if (step) {
      result = await step.ai.infer(stepID, {
        model: __privateGet(this, _model),
        body
      });
    } else {
      const modelCopy = __spreadValues({}, __privateGet(this, _model));
      (_b = (_a = __privateGet(this, _model)).onCall) == null ? void 0 : _b.call(_a, modelCopy, body);
      const url = new URL(modelCopy.url || "");
      const headers = {
        "Content-Type": "application/json"
      };
      const formatHandlers = {
        "openai-chat": () => {
          headers["Authorization"] = `Bearer ${modelCopy.authKey}`;
        },
        "azure-openai": () => {
          headers["api-key"] = modelCopy.authKey;
        },
        anthropic: () => {
          headers["x-api-key"] = modelCopy.authKey;
          headers["anthropic-version"] = "2023-06-01";
        },
        gemini: () => {
        },
        grok: () => {
        }
      };
      formatHandlers[modelCopy.format]();
      result = await (await fetch(url, {
        method: "POST",
        headers,
        body: JSON.stringify(body)
      })).json();
    }
    return { output: this.responseParser(result), raw: result };
  }
};
_model = new WeakMap();

// src/agent.ts
var createAgent = (opts) => new Agent(opts);
var createRoutingAgent = (opts) => new RoutingAgent(opts);
var Agent = class _Agent {
  constructor(opts) {
    this.name = opts.name;
    this.description = opts.description || "";
    this.system = opts.system;
    this.assistant = opts.assistant || "";
    this.tools = /* @__PURE__ */ new Map();
    this.tool_choice = opts.tool_choice;
    this.lifecycles = opts.lifecycle;
    this.model = opts.model;
    this.history = opts.history;
    this.setTools(opts.tools);
    this.mcpServers = opts.mcpServers;
    this._mcpClients = [];
  }
  setTools(tools) {
    for (const tool of tools || []) {
      if (isInngestFn(tool)) {
        this.tools.set(tool["absoluteId"], {
          name: tool["absoluteId"],
          description: tool.description,
          // TODO Should we error here if we can't find an input schema?
          parameters: getInngestFnInput(tool),
          handler: async (input, opts) => {
            const step = await getStepTools();
            if (!step) {
              throw new Error("Inngest tool called outside of Inngest context");
            }
            const stepId = `${opts.agent.name}/tools/${tool["absoluteId"]}`;
            return step.invoke(stepId, {
              function: (0, import_inngest7.referenceFunction)({
                appId: tool["client"]["id"],
                functionId: tool.id()
              }),
              data: input
            });
          }
        });
      } else {
        this.tools.set(tool.name, tool);
      }
    }
  }
  withModel(model) {
    return new _Agent({
      name: this.name,
      description: this.description,
      system: this.system,
      assistant: this.assistant,
      tools: Array.from(this.tools.values()),
      lifecycle: this.lifecycles,
      model
    });
  }
  /**
   * Run runs an agent with the given user input, treated as a user message.  If
   * the input is an empty string, only the system prompt will execute.
   */
  async run(input, {
    model,
    network,
    state,
    maxIter = 0,
    streaming,
    streamingContext,
    step
  } = {}) {
    var _a, _b;
    await this.initMCP();
    const rawModel = model || this.model || (network == null ? void 0 : network.defaultModel);
    if (!rawModel) {
      throw new Error("No model provided to agent");
    }
    const p = createAgenticModelFromAiAdapter(rawModel);
    const s = state || (network == null ? void 0 : network.state) || new State();
    const run = new NetworkRun(
      network || createNetwork({ name: "default", agents: [] }),
      s
    );
    let standaloneStreamingContext;
    let standaloneWrappedStep;
    if (!network && (streaming == null ? void 0 : streaming.publish)) {
      const stepTools = await getStepTools();
      let agentRunId;
      let messageId;
      if (stepTools) {
        const ids = await stepTools.run("generate-standalone-agent-ids", () => {
          return {
            agentRunId: generateId(),
            messageId: (0, import_crypto2.randomUUID)()
          };
        });
        agentRunId = ids.agentRunId;
        messageId = ids.messageId;
      } else {
        agentRunId = generateId();
        messageId = (0, import_crypto2.randomUUID)();
      }
      standaloneStreamingContext = StreamingContext.fromNetworkState(s, {
        publish: streaming.publish,
        runId: agentRunId,
        messageId,
        scope: "agent",
        simulateChunking: streaming.simulateChunking
      });
      standaloneWrappedStep = createStepWrapper(
        stepTools,
        standaloneStreamingContext
      );
      await standaloneStreamingContext.publishEvent({
        event: "run.started",
        data: {
          runId: agentRunId,
          scope: "agent",
          name: this.name,
          messageId,
          threadId: s.threadId
        }
      });
    }
    const effectiveStreamingContext = streamingContext || standaloneStreamingContext;
    const effectiveStep = step || standaloneWrappedStep;
    const inputContent = typeof input === "object" && input !== null && "content" in input ? input.content : input;
    await initializeThread({
      state: s,
      history: this.history,
      input: inputContent,
      network: run
    });
    await loadThreadFromStorage({
      state: s,
      history: this.history,
      input: inputContent,
      network: run
    });
    let history = s ? s.formatHistory() : [];
    let prompt = await this.agentPrompt(input, run);
    let result = new AgentResult(
      this.name,
      [],
      [],
      /* @__PURE__ */ new Date(),
      prompt,
      history,
      ""
    );
    let hasMoreActions = true;
    let iter = 0;
    const initialResultCount = s.results.length;
    try {
      do {
        if ((_a = this.lifecycles) == null ? void 0 : _a.onStart) {
          const modified = await this.lifecycles.onStart({
            agent: this,
            network: run,
            input: inputContent,
            prompt,
            history
          });
          if (modified.stop) {
            return result;
          }
          prompt = modified.prompt;
          history = modified.history;
        }
        const inference = await this.performInference(
          p,
          prompt,
          history,
          run,
          effectiveStreamingContext,
          effectiveStep
        );
        hasMoreActions = Boolean(
          this.tools.size > 0 && inference.output.length && inference.output[inference.output.length - 1].stop_reason !== "stop"
        );
        result = inference;
        if (standaloneStreamingContext) {
          result.id = standaloneStreamingContext.messageId;
        }
        history = [...inference.output];
        iter++;
      } while (hasMoreActions && iter < maxIter);
      if ((_b = this.lifecycles) == null ? void 0 : _b.onFinish) {
        result = await this.lifecycles.onFinish({
          agent: this,
          network: run,
          result
        });
      }
      await saveThreadToStorage({
        state: s,
        history: this.history,
        input: inputContent,
        initialResultCount,
        network: run
      });
    } catch (error) {
      if (standaloneStreamingContext) {
        try {
          await standaloneStreamingContext.publishEvent({
            event: "run.failed",
            data: {
              runId: standaloneStreamingContext.runId,
              scope: "agent",
              name: this.name,
              error: error instanceof Error ? error.message : String(error),
              recoverable: false
            }
          });
        } catch (streamingError) {
          console.warn("Failed to publish run.failed event:", streamingError);
        }
      }
      throw error;
    } finally {
      if (standaloneStreamingContext) {
        try {
          await standaloneStreamingContext.publishEvent({
            event: "run.completed",
            data: {
              runId: standaloneStreamingContext.runId,
              scope: "agent",
              name: this.name
            }
          });
          await standaloneStreamingContext.publishEvent({
            event: "stream.ended",
            data: {
              scope: "agent",
              messageId: standaloneStreamingContext.messageId
            }
          });
        } catch (streamingError) {
          console.warn("Failed to publish completion events:", streamingError);
        }
      }
    }
    return result;
  }
  async performInference(p, prompt, history, network, streamingContext, step) {
    var _a;
    const { output, raw } = await p.infer(
      this.name,
      prompt.concat(history),
      Array.from(this.tools.values()),
      this.tool_choice || "auto"
    );
    let result = new AgentResult(
      this.name,
      output,
      [],
      /* @__PURE__ */ new Date(),
      prompt,
      history,
      typeof raw === "string" ? raw : JSON.stringify(raw)
    );
    if ((_a = this.lifecycles) == null ? void 0 : _a.onResponse) {
      result = await this.lifecycles.onResponse({
        agent: this,
        network,
        result
      });
    }
    if (streamingContext) {
      const lastTextMsg = [...result.output].reverse().find((m) => m.type === "text" && m.role === "assistant");
      let content = "";
      if (lastTextMsg && lastTextMsg.type === "text") {
        const anyMsg = lastTextMsg;
        if (typeof anyMsg.content === "string") {
          content = anyMsg.content;
        } else if (Array.isArray(anyMsg.content)) {
          content = anyMsg.content.map((c) => c.text).join("");
        }
      }
      if (content && content.length > 0) {
        const stepTools = step || await getStepTools();
        const partId = stepTools ? await stepTools.run(
          `generate-text-part-id-${streamingContext.messageId}`,
          () => {
            return streamingContext.generatePartId();
          }
        ) : streamingContext.generatePartId();
        await streamingContext.publishEvent({
          event: "part.created",
          data: {
            partId,
            runId: streamingContext.runId,
            messageId: streamingContext.messageId,
            type: "text",
            metadata: { agentName: this.name }
          }
        });
        if (streamingContext.isSimulatedChunking()) {
          const chunkSize = 50;
          for (let i = 0; i < content.length; i += chunkSize) {
            await streamingContext.publishEvent({
              event: "text.delta",
              data: {
                partId,
                messageId: streamingContext.messageId,
                delta: content.slice(i, i + chunkSize)
              }
            });
          }
        } else {
          await streamingContext.publishEvent({
            event: "text.delta",
            data: {
              partId,
              messageId: streamingContext.messageId,
              delta: content
            }
          });
        }
        await streamingContext.publishEvent({
          event: "part.completed",
          data: {
            partId,
            runId: streamingContext.runId,
            messageId: streamingContext.messageId,
            type: "text",
            finalContent: content
          }
        });
      }
    }
    const toolCallOutput = await this.invokeTools(
      result.output,
      network,
      streamingContext,
      step
    );
    if (toolCallOutput.length > 0) {
      result.toolCalls = result.toolCalls.concat(toolCallOutput);
    }
    return result;
  }
  /**
   * invokeTools takes output messages from an inference call then invokes any tools
   * in the message responses.
   */
  async invokeTools(msgs, network, streamingContext, step) {
    var _a, _b;
    const output = [];
    for (const msg of msgs) {
      if (msg.type !== "tool_call") {
        continue;
      }
      if (!Array.isArray(msg.tools)) {
        continue;
      }
      for (const tool of msg.tools) {
        const found = this.tools.get(tool.name);
        if (!found) {
          throw new Error(
            `Inference requested a non-existent tool: ${tool.name}`
          );
        }
        const toolArgsJson = JSON.stringify((_a = tool.input) != null ? _a : {});
        if (streamingContext) {
          const stepTools = step || await getStepTools();
          const toolCallPartId = stepTools ? await stepTools.run(
            `generate-tool-part-id-${streamingContext.messageId}-${tool.name}`,
            () => {
              return streamingContext.generatePartId();
            }
          ) : streamingContext.generatePartId();
          await streamingContext.publishEvent({
            event: "part.created",
            data: {
              partId: toolCallPartId,
              runId: streamingContext.runId,
              messageId: streamingContext.messageId,
              type: "tool-call",
              metadata: { toolName: tool.name, agentName: this.name }
            }
          });
          if (streamingContext.isSimulatedChunking()) {
            const argChunkSize = 50;
            for (let i = 0; i < toolArgsJson.length; i += argChunkSize) {
              await streamingContext.publishEvent({
                event: "tool_call.arguments.delta",
                data: {
                  partId: toolCallPartId,
                  delta: toolArgsJson.slice(i, i + argChunkSize),
                  toolName: i === 0 ? tool.name : void 0,
                  messageId: streamingContext.messageId
                }
              });
            }
          } else {
            await streamingContext.publishEvent({
              event: "tool_call.arguments.delta",
              data: {
                partId: toolCallPartId,
                delta: toolArgsJson,
                toolName: tool.name,
                messageId: streamingContext.messageId
              }
            });
          }
          await streamingContext.publishEvent({
            event: "part.completed",
            data: {
              partId: toolCallPartId,
              runId: streamingContext.runId,
              messageId: streamingContext.messageId,
              type: "tool-call",
              finalContent: (_b = tool.input) != null ? _b : {},
              metadata: { toolName: tool.name, agentName: this.name }
            }
          });
        }
        const result = await Promise.resolve(
          found.handler(tool.input, {
            agent: this,
            network,
            step
          })
        ).then((r) => {
          return {
            data: typeof r === "undefined" ? `${tool.name} successfully executed` : r
          };
        }).catch((err) => {
          return { error: import_internals.errors.serializeError(err) };
        });
        if (streamingContext) {
          const stepTools = step || await getStepTools();
          const outputPartId = stepTools ? await stepTools.run(
            `generate-output-part-id-${streamingContext.messageId}-${tool.name}`,
            () => {
              return streamingContext.generatePartId();
            }
          ) : streamingContext.generatePartId();
          await streamingContext.publishEvent({
            event: "part.created",
            data: {
              partId: outputPartId,
              runId: streamingContext.runId,
              messageId: streamingContext.messageId,
              type: "tool-output",
              metadata: { toolName: tool.name, agentName: this.name }
            }
          });
          const resultJson = JSON.stringify(result);
          if (streamingContext.isSimulatedChunking()) {
            const outChunk = 80;
            for (let i = 0; i < resultJson.length; i += outChunk) {
              await streamingContext.publishEvent({
                event: "tool_call.output.delta",
                data: {
                  partId: outputPartId,
                  delta: resultJson.slice(i, i + outChunk),
                  messageId: streamingContext.messageId
                }
              });
            }
          } else {
            await streamingContext.publishEvent({
              event: "tool_call.output.delta",
              data: {
                partId: outputPartId,
                delta: resultJson,
                messageId: streamingContext.messageId
              }
            });
          }
          await streamingContext.publishEvent({
            event: "part.completed",
            data: {
              partId: outputPartId,
              runId: streamingContext.runId,
              messageId: streamingContext.messageId,
              type: "tool-output",
              finalContent: result,
              metadata: { toolName: tool.name, agentName: this.name }
            }
          });
        }
        output.push({
          role: "tool_result",
          type: "tool_result",
          tool: {
            type: "tool",
            id: tool.id,
            name: tool.name,
            input: tool.input.arguments
          },
          content: result,
          stop_reason: "tool"
        });
      }
    }
    return output;
  }
  async agentPrompt(input, network) {
    const systemContent = typeof this.system === "string" ? this.system : await this.system({ network });
    const inputContent = typeof input === "object" && input !== null && "content" in input ? input.content : input;
    const userSystemPrompt = typeof input === "object" && input !== null && "systemPrompt" in input ? input.systemPrompt : void 0;
    const messages = [
      {
        type: "text",
        role: "system",
        content: userSystemPrompt ? `${systemContent}

${userSystemPrompt}` : systemContent
      }
    ];
    if (inputContent.length > 0) {
      messages.push({ type: "text", role: "user", content: inputContent });
    }
    if (this.assistant.length > 0) {
      messages.push({
        type: "text",
        role: "assistant",
        content: this.assistant
      });
    }
    return messages;
  }
  // initMCP fetches all tools from the agent's MCP servers, adding them to the tool list.
  // This is all that's necessary in order to enable MCP tool use within agents
  async initMCP() {
    if (!this.mcpServers || this._mcpClients.length >= this.mcpServers.length) {
      return;
    }
    const promises = [];
    for (const server of this.mcpServers) {
      promises.push(this.listMCPTools(server));
    }
    await Promise.all(promises);
  }
  /**
   * listMCPTools lists all available tools for a given MCP server
   */
  async listMCPTools(server) {
    const { JSONSchemaToZod } = await import("@dmitryrechkin/json-schema-to-zod");
    const client = await this.mcpClient(server);
    this._mcpClients.push(client);
    try {
      const results = await client.request(
        { method: "tools/list" },
        import_types6.ListToolsResultSchema
      );
      results.tools.forEach((t) => {
        const name = `${server.name}-${t.name}`;
        let zschema;
        try {
          zschema = JSONSchemaToZod.convert(
            t.inputSchema
          );
        } catch (e) {
          zschema = void 0;
        }
        this.tools.set(name, {
          name,
          description: t.description,
          parameters: zschema,
          mcp: {
            server,
            tool: t
          },
          handler: async (input) => {
            var _a;
            const fn = () => client.callTool({
              name: t.name,
              arguments: input
            });
            const step = await getStepTools();
            const result = await ((_a = step == null ? void 0 : step.run(name, fn)) != null ? _a : fn());
            return result.content;
          }
        });
      });
    } catch (e) {
      console.warn("error listing mcp tools", e);
    }
  }
  /**
   * mcpClient creates a new MCP client for the given server.
   */
  async mcpClient(server) {
    const transport = (() => {
      switch (server.transport.type) {
        case "streamable-http":
          return new import_streamableHttp.StreamableHTTPClientTransport(
            new URL(server.transport.url),
            {
              requestInit: server.transport.requestInit,
              authProvider: server.transport.authProvider,
              reconnectionOptions: server.transport.reconnectionOptions,
              sessionId: server.transport.sessionId
            }
          );
        case "sse":
          if (global.EventSource === void 0) {
            global.EventSource = import_eventsource.EventSource;
          }
          return new import_sse.SSEClientTransport(new URL(server.transport.url), {
            eventSourceInit: server.transport.eventSourceInit,
            requestInit: server.transport.requestInit
          });
        case "ws":
          return new import_websocket.WebSocketClientTransport(new URL(server.transport.url));
        case "stdio": {
          const { command, args, env } = server.transport;
          const safeProcessEnv = Object.fromEntries(
            Object.entries(process.env).filter(([, v]) => v !== void 0)
          );
          const finalEnv = __spreadValues(__spreadValues({}, safeProcessEnv), env);
          return new import_stdio.StdioClientTransport({
            command,
            args,
            env: finalEnv
          });
        }
      }
    })();
    const client = new import_client.Client(
      {
        name: this.name,
        // XXX: This version should change.
        version: "1.0.0"
      },
      {
        capabilities: {}
      }
    );
    try {
      await client.connect(transport);
    } catch (e) {
      console.warn("mcp server disconnected", server, e);
    }
    return client;
  }
};
var RoutingAgent = class _RoutingAgent extends Agent {
  constructor(opts) {
    super(opts);
    this.type = "routing";
    this.lifecycles = opts.lifecycle;
  }
  withModel(model) {
    return new _RoutingAgent({
      name: this.name,
      description: this.description,
      system: this.system,
      assistant: this.assistant,
      tools: Array.from(this.tools.values()),
      lifecycle: this.lifecycles,
      model
    });
  }
};

// src/models.ts
var import_ai9 = require("@inngest/ai");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Agent,
  AgentMessageChunkSchema,
  AgentResult,
  AgenticModel,
  Network,
  NetworkRun,
  RoutingAgent,
  State,
  StreamingContext,
  anthropic,
  createAgent,
  createAgenticModelFromAiAdapter,
  createNetwork,
  createRoutingAgent,
  createState,
  createStepWrapper,
  createTool,
  createToolManifest,
  gemini,
  generateId,
  getDefaultRoutingAgent,
  getInngestFnInput,
  getStepTools,
  grok,
  initializeThread,
  isEventType,
  isInngestFn,
  loadThreadFromStorage,
  openai,
  saveThreadToStorage,
  stringifyError
});
//# sourceMappingURL=index.cjs.map